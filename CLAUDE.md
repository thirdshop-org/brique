# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**Brique** is an offline-first, local-first resilience infrastructure for repair and local mutual aid. It's designed on the principle that "the Internet is not eternal, but our objects are."

- **0% Cloud**: No data stored on remote centralized servers
- **Local-First**: Fully functional without network connection
- **Anti-Obsolescence**: Extends object lifespan by securing maintenance knowledge

The application stores an inventory of physical objects (appliances, tools, electronics) along with their repair documentation (PDFs, schematics, 3D files for spare parts).

## Build and Run Commands

### CLI Application

```bash
# Build the CLI
go build -o brique ./cmd/brique-cli

# Run CLI commands
./brique item list
./brique item add
./brique item get <id>
./brique asset add <item-id> <file> -t manual -n "User Manual"
```

### GUI Application (Wails)

```bash
# Development mode with hot reload
wails dev

# Build for production
wails build

# Frontend only (for UI development)
cd frontend
npm install
npm run dev
npm run build
```

### Testing

```bash
# Run Go unit tests
go test ./core/services/... -v

# Run all tests
go test ./... -v

# Run integration test script
./test_complete.sh
```

### Database and Code Generation

```bash
# Generate type-safe SQL code (after modifying queries in core/db/queries/)
sqlc generate

# The migrations run automatically on app startup
# To manually inspect the database:
sqlite3 ~/.config/brique/brique.db
```

## Architecture

### Core Design Pattern: Layered Architecture

The codebase follows a strict separation of concerns:

1. **models/** (core/models): Domain entities shared across layers
2. **db/** (core/db): Data access layer - contains sqlc-generated code and database setup
3. **services/** (core/services): Business logic layer - contains BackpackService and future services
4. **cmd/** (cmd/brique-cli, main.go): Application entry points (CLI and GUI)

**Important**: Business logic lives in services, NOT in handlers or cmd. Services are interface-agnostic and can be used by both CLI and GUI.

### Database: SQLite + sqlc Workflow

The project uses **sqlc** to generate type-safe Go code from SQL queries:

1. **Schema**: Defined in `migrations/*.sql` (goose format)
2. **Queries**: Written in `core/db/queries/*.sql` with sqlc annotations
3. **Generated Code**: `core/db/*.sql.go` (DO NOT EDIT manually)

When adding new queries:
1. Add them to `core/db/queries/items.sql` or `core/db/queries/assets.sql`
2. Use sqlc annotations: `-- name: MethodName :one` or `:many` or `:exec`
3. Run `sqlc generate` to regenerate Go code
4. Use the generated methods via `*db.Queries` in services

**Migration workflow**:
- Migrations are embedded and run automatically on app startup
- Create new migrations as `migrations/0000X_description.sql` with goose format
- Migrations are applied in order, tracked in SQLite's `goose_db_version` table

### Service Layer Pattern: BackpackService

The `BackpackService` (core/services/backpack_service.go) is the core business logic:

```go
type BackpackService struct {
    queries   *db.Queries      // sqlc-generated database queries
    assetsDir string          // filesystem path for storing files
}
```

**Key responsibilities**:
- CRUD operations on items and assets
- File management (copy files to assets directory, calculate SHA256 hashes)
- Documentation health calculation (incomplete/partial/secured based on asset types)
- Search functionality

The service uses `*db.Queries` (generated by sqlc) for all database operations. It never uses raw SQL.

### Wails Integration (GUI)

The GUI is built with Wails v2, which bridges Go backend with Svelte frontend:

1. **main.go**: Wails app entry point, creates App struct, binds it to frontend
2. **app_handlers.go**: Methods on App struct that are exposed to frontend via Wails binding
3. **frontend/**: Svelte + TypeScript + Tailwind CSS

**Data flow**:
- Frontend calls Go methods via Wails runtime (type-safe TypeScript bindings auto-generated)
- App handlers (app_handlers.go) convert between DTOs and domain models
- Handlers delegate to BackpackService for business logic
- Service uses db.Queries for database access

**Important**: The App struct in main.go owns the database connection and services. It's initialized in `startup()` and cleaned up in `shutdown()`.

### Frontend Architecture (Svelte)

- **Safe Fetch Pattern**: All backend calls use tuple return `[data, error]` pattern (see `frontend/src/lib/utils/safe.ts`)
- **Tailwind + Shadcn**: Uses Slate color palette with 0.25rem border radius
- **Components**: ItemCard displays items with documentation health status (ðŸŸ¢ðŸŸ¡ðŸ”´)
- **Search**: Client-side filtering for instant search results

### Data Storage

Data is stored in OS-specific locations:
- **Linux**: `~/.config/brique/`
- **Windows**: `%APPDATA%\Brique\`
- **macOS**: `~/Library/Application Support/Brique/`

Structure:
```
~/.config/brique/
â”œâ”€â”€ brique.db           # SQLite database
â””â”€â”€ assets/             # Files (PDFs, STLs, etc.)
    â””â”€â”€ item_<id>/      # One folder per item
```

**Headless mode**: When run as root, defaults to `/var/lib/brique/` (for Raspberry Pi deployment).

### Asset Types and Documentation Health

Assets have types: `manual`, `service_manual`, `exploded_view`, `stl`, `firmware`, `driver`, `schematic`, `other`

Documentation health is calculated as:
- **ðŸŸ¢ Secured**: Has both `manual` AND `service_manual`
- **ðŸŸ¡ Partial**: Has some assets but not both required types
- **ðŸ”´ Incomplete**: No assets

This logic is in `BackpackService.calculateDocumentationHealth()`.

## Important Implementation Notes

### Type Safety with sqlc

All database operations are type-safe through sqlc:
- Query parameters are validated at compile time
- Result types are automatically generated
- No SQL injection possible (uses prepared statements)

Never bypass the service layer to execute raw SQL directly.

### File Management

When adding assets via `BackpackService.AddAsset()`:
1. File is copied (not moved) from source to `assets/item_<id>/`
2. SHA256 hash is calculated for integrity verification
3. File size is recorded
4. Original filename is preserved in the database

### Context Usage

All service methods accept `context.Context` as first parameter for:
- Cancellation support
- Timeout handling
- Graceful shutdown

The CLI creates a root context, while Wails provides per-request contexts.

### Testing Philosophy

Tests use in-memory SQLite databases (`:memory:`) for isolation. Each test:
1. Creates a fresh database
2. Runs migrations
3. Performs operations
4. Cleans up automatically

See `core/services/backpack_service_test.go` for examples.

## Future Modules

The "Gossip Grids" P2P synchronization module (planned) will be implemented as a separate service following the same pattern as BackpackService.

## CLI Command Structure

Commands follow the pattern: `brique <resource> <action> [args] [flags]`

Example: `brique asset add 1 manual.pdf -t manual -n "User Manual"`

Interactive prompts use `bufio.Reader` to support spaces in input (not `fmt.Scan`).
